// -------------------------------------------------------------
// 
// File Name: hdlsrc\DNN\OutputLayer.v
// Created: 2024-09-19 22:24:12
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: OutputLayer
// Source Path: DNN/DNNModel/OutputLayer
// Hierarchy Level: 1
// Model version: 1.53
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module OutputLayer
          (Bias,
           Weight_0,
           Weight_1,
           Weight_2,
           Weight_3,
           X_0,
           X_1,
           X_2,
           X_3,
           ySig);


  input   signed [1:0] Bias;  // sfix2_En2
  input   signed [6:0] Weight_0;  // sfix7_En4
  input   signed [6:0] Weight_1;  // sfix7_En4
  input   signed [6:0] Weight_2;  // sfix7_En4
  input   signed [6:0] Weight_3;  // sfix7_En4
  input   signed [15:0] X_0;  // sfix16_En14
  input   signed [15:0] X_1;  // sfix16_En14
  input   signed [15:0] X_2;  // sfix16_En14
  input   signed [15:0] X_3;  // sfix16_En14
  output  signed [15:0] ySig;  // sfix16_En14


  wire signed [6:0] Weight [0:3];  // sfix7_En4 [4]
  wire signed [15:0] X [0:3];  // sfix16_En14 [4]
  reg signed [15:0] ySig_1;  // sfix16_En14
  reg signed [15:0] PM;  // sfix16_En10
  reg signed [15:0] WS;  // sfix16_En10
  reg signed [22:0] prodAB;  // sfix23_En18
  reg signed [24:0] c;  // sfix25_En18
  reg signed [31:0] k;  // int32
  reg signed [15:0] y;  // sfix16_En10
  reg signed [16:0] add_cast;  // sfix17_En10
  reg signed [16:0] add_cast_0;  // sfix17_En10
  reg signed [16:0] add_temp;  // sfix17_En10
  reg signed [25:0] add_cast_1 [0:3];  // sfix26_En18 [4]
  reg signed [25:0] add_cast_2 [0:3];  // sfix26_En18 [4]
  reg signed [25:0] add_temp_0 [0:3];  // sfix26_En18 [4]
  reg signed [31:0] mul_temp;  // sfix32_En20
  reg signed [32:0] add_cast_3;  // sfix33_En20
  reg signed [32:0] add_temp_1;  // sfix33_En20
  reg signed [31:0] mul_temp_0;  // sfix32_En20
  reg signed [32:0] add_cast_4;  // sfix33_En20
  reg signed [32:0] add_temp_2;  // sfix33_En20
  reg signed [31:0] mul_temp_1;  // sfix32_En20
  reg signed [32:0] add_cast_5;  // sfix33_En20
  reg signed [32:0] add_temp_3;  // sfix33_En20


  assign Weight[0] = Weight_0;
  assign Weight[1] = Weight_1;
  assign Weight[2] = Weight_2;
  assign Weight[3] = Weight_3;

  assign X[0] = X_0;
  assign X[1] = X_1;
  assign X[2] = X_2;
  assign X[3] = X_3;

  always @* begin
    prodAB = 23'sb00000000000000000000000;
    mul_temp = 32'sb00000000000000000000000000000000;
    add_temp_1 = 33'sh000000000;
    mul_temp_0 = 32'sb00000000000000000000000000000000;
    add_temp_2 = 33'sh000000000;
    mul_temp_1 = 32'sb00000000000000000000000000000000;
    add_temp_3 = 33'sh000000000;
    add_cast_3 = 33'sh000000000;
    add_cast_4 = 33'sh000000000;
    add_cast_5 = 33'sh000000000;
    // ytan = NN_Layer_Tanh_HDL(Bias,Weight,X)
    // This function implements NN Layer using Tanh Function
    // It is HDL supported, it can be used in HDL Code Generation
    // where
    //     Weight = Weights should be arranged as Row Vector
    //     X = Instances of Input Features should be arranged as Row Vector
    //     Bias = it can be Row or Column Vector
    //     Y = It is output vector (arranged as Column Vector)
    //         from all neurons of given layer.
    // Note: All inputs of this function should be in fixed point form
    // Word Length
    // Fractional Length
    c = 25'sb0000000000000000000000000;

    for(k = 32'sd0; k <= 32'sd3; k = k + 32'sd1) begin
      prodAB = Weight[k] * X[k];
      add_cast_1[k] = {c[24], c};
      add_cast_2[k] = {{3{prodAB[22]}}, prodAB};
      add_temp_0[k] = add_cast_1[k] + add_cast_2[k];
      if ((add_temp_0[k][25] == 1'b0) && (add_temp_0[k][24] != 1'b0)) begin
        c = 25'sb0111111111111111111111111;
      end
      else if ((add_temp_0[k][25] == 1'b1) && (add_temp_0[k][24] != 1'b1)) begin
        c = 25'sb1000000000000000000000000;
      end
      else begin
        c = add_temp_0[k][24:0];
      end
    end

    if (((c[24] == 1'b0) && (c[23] != 1'b0)) || ((c[24] == 1'b0) && (c[23:8] == 16'sb0111111111111111))) begin
      PM = 16'sb0111111111111111;
    end
    else if ((c[24] == 1'b1) && (c[23] != 1'b1)) begin
      PM = 16'sb1000000000000000;
    end
    else begin
      PM = c[23:8] + $signed({1'b0, c[7]});
    end
    add_cast = {PM[15], PM};
    add_cast_0 = {{7{Bias[1]}}, {Bias, 8'b00000000}};
    add_temp = add_cast + add_cast_0;
    if ((add_temp[16] == 1'b0) && (add_temp[15] != 1'b0)) begin
      WS = 16'sb0111111111111111;
    end
    else if ((add_temp[16] == 1'b1) && (add_temp[15] != 1'b1)) begin
      WS = 16'sb1000000000000000;
    end
    else begin
      WS = add_temp[15:0];
    end
    // Word Length
    // Fractional Length
    // Initialize HDL math object
    // Create numeric type
    // Convert input to fixed-point
    // Slopes and Offsets
    // Piecewise Linear Approximation of Sigmoid Function
    if (WS < 16'sb1111010000000000) begin
      y = 16'sb1111110000000000;
    end
    else if (WS < 16'sb1111100000000000) begin
      mul_temp = 16'sb0000000001001010 * WS;
      add_cast_3 = {mul_temp[31], mul_temp};
      add_temp_1 = add_cast_3 + 33'sh000038400;
      y = add_temp_1[25:10];
    end
    else if ((WS >= 16'sb1111100000000000) && (WS <= 16'sb0000100000000000)) begin
      mul_temp_0 = 16'sb0000000011010111 * WS;
      add_cast_4 = {mul_temp_0[31], mul_temp_0};
      add_temp_2 = add_cast_4 + 33'sh000080000;
      y = add_temp_2[25:10];
    end
    else if (WS < 16'sb0000110000000000) begin
      mul_temp_1 = 16'sb0000000001001010 * WS;
      add_cast_5 = {mul_temp_1[31], mul_temp_1};
      add_temp_3 = add_cast_5 + 33'sh0000C7C00;
      y = add_temp_3[25:10];
    end
    else begin
      y = 16'sb0000010000000000;
    end
    // Saturation between 0 and 1
    if (y <= 16'sb0000000000000000) begin
      y = 16'sb0000000000000000;
    end
    else if (y >= 16'sb0000010000000000) begin
      y = 16'sb0000010000000000;
    end
    if ((y[15] == 1'b0) && (y[14:11] != 4'b0000)) begin
      ySig_1 = 16'sb0111111111111111;
    end
    else if ((y[15] == 1'b1) && (y[14:11] != 4'b1111)) begin
      ySig_1 = 16'sb1000000000000000;
    end
    else begin
      ySig_1 = {y[11:0], 4'b0000};
    end
  end



  assign ySig = ySig_1;

endmodule  // OutputLayer


// -------------------------------------------------------------
// 
// File Name: hdlsrc\DNN\HiddenLayer1.v
// Created: 2024-09-19 22:24:12
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: HiddenLayer1
// Source Path: DNN/DNNModel/HiddenLayer1
// Hierarchy Level: 1
// Model version: 1.53
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HiddenLayer1
          (Bias_0,
           Bias_1,
           Bias_2,
           Weight_0,
           Weight_1,
           Weight_2,
           Weight_3,
           Weight_4,
           Weight_5,
           Weight_6,
           Weight_7,
           Weight_8,
           Weight_9,
           Weight_10,
           Weight_11,
           Weight_12,
           Weight_13,
           Weight_14,
           Weight_15,
           Weight_16,
           Weight_17,
           Weight_18,
           Weight_19,
           Weight_20,
           X_0,
           X_1,
           X_2,
           X_3,
           X_4,
           X_5,
           X_6,
           ytan_0,
           ytan_1,
           ytan_2);


  input   signed [4:0] Bias_0;  // sfix5_En3
  input   signed [4:0] Bias_1;  // sfix5_En3
  input   signed [4:0] Bias_2;  // sfix5_En3
  input   signed [9:0] Weight_0;  // sfix10_En7
  input   signed [9:0] Weight_1;  // sfix10_En7
  input   signed [9:0] Weight_2;  // sfix10_En7
  input   signed [9:0] Weight_3;  // sfix10_En7
  input   signed [9:0] Weight_4;  // sfix10_En7
  input   signed [9:0] Weight_5;  // sfix10_En7
  input   signed [9:0] Weight_6;  // sfix10_En7
  input   signed [9:0] Weight_7;  // sfix10_En7
  input   signed [9:0] Weight_8;  // sfix10_En7
  input   signed [9:0] Weight_9;  // sfix10_En7
  input   signed [9:0] Weight_10;  // sfix10_En7
  input   signed [9:0] Weight_11;  // sfix10_En7
  input   signed [9:0] Weight_12;  // sfix10_En7
  input   signed [9:0] Weight_13;  // sfix10_En7
  input   signed [9:0] Weight_14;  // sfix10_En7
  input   signed [9:0] Weight_15;  // sfix10_En7
  input   signed [9:0] Weight_16;  // sfix10_En7
  input   signed [9:0] Weight_17;  // sfix10_En7
  input   signed [9:0] Weight_18;  // sfix10_En7
  input   signed [9:0] Weight_19;  // sfix10_En7
  input   signed [9:0] Weight_20;  // sfix10_En7
  input   signed [11:0] X_0;  // sfix12_En11
  input   signed [11:0] X_1;  // sfix12_En11
  input   signed [11:0] X_2;  // sfix12_En11
  input   signed [11:0] X_3;  // sfix12_En11
  input   signed [11:0] X_4;  // sfix12_En11
  input   signed [11:0] X_5;  // sfix12_En11
  input   signed [11:0] X_6;  // sfix12_En11
  output  signed [15:0] ytan_0;  // sfix16_En14
  output  signed [15:0] ytan_1;  // sfix16_En14
  output  signed [15:0] ytan_2;  // sfix16_En14


  wire signed [4:0] Bias [0:2];  // sfix5_En3 [3]
  wire signed [9:0] Weight [0:2] [0:6];  // sfix10_En7 [3x7]
  wire signed [11:0] X [0:6];  // sfix12_En11 [7]
  reg signed [15:0] ytan [0:2];  // sfix16_En14 [3]
  reg signed [31:0] k;  // int32
  reg signed [21:0] prodAB;  // sfix22_En18
  reg signed [24:0] c;  // sfix25_En18
  reg signed [31:0] k_0;  // int32
  reg signed [15:0] y;  // sfix16_En10
  reg signed [15:0] slice_temp;  // sfix16_En10
  reg signed [15:0] add_cast [0:2];  // sfix16_En10 [3]
  reg signed [16:0] add_cast_0 [0:2];  // sfix17_En10 [3]
  reg signed [16:0] add_cast_1 [0:2];  // sfix17_En10 [3]
  reg signed [16:0] add_temp [0:2];  // sfix17_En10 [3]
  reg signed [25:0] add_cast_2 [0:6];  // sfix26_En18 [7]
  reg signed [25:0] add_cast_3 [0:6];  // sfix26_En18 [7]
  reg signed [25:0] add_temp_0 [0:6];  // sfix26_En18 [7]
  reg signed [31:0] mul_temp [0:2];  // sfix32_En20 [3]
  reg signed [32:0] add_cast_4 [0:2];  // sfix33_En20 [3]
  reg signed [32:0] add_temp_1 [0:2];  // sfix33_En20 [3]
  reg signed [31:0] mul_temp_0 [0:2];  // sfix32_En20 [3]
  reg signed [31:0] mul_temp_1 [0:2];  // sfix32_En20 [3]
  reg signed [32:0] add_cast_5 [0:2];  // sfix33_En20 [3]
  reg signed [32:0] add_temp_2 [0:2];  // sfix33_En20 [3]


  assign Bias[0] = Bias_0;
  assign Bias[1] = Bias_1;
  assign Bias[2] = Bias_2;

  assign Weight[0][0] = Weight_0;
  assign Weight[1][0] = Weight_1;
  assign Weight[2][0] = Weight_2;
  assign Weight[0][1] = Weight_3;
  assign Weight[1][1] = Weight_4;
  assign Weight[2][1] = Weight_5;
  assign Weight[0][2] = Weight_6;
  assign Weight[1][2] = Weight_7;
  assign Weight[2][2] = Weight_8;
  assign Weight[0][3] = Weight_9;
  assign Weight[1][3] = Weight_10;
  assign Weight[2][3] = Weight_11;
  assign Weight[0][4] = Weight_12;
  assign Weight[1][4] = Weight_13;
  assign Weight[2][4] = Weight_14;
  assign Weight[0][5] = Weight_15;
  assign Weight[1][5] = Weight_16;
  assign Weight[2][5] = Weight_17;
  assign Weight[0][6] = Weight_18;
  assign Weight[1][6] = Weight_19;
  assign Weight[2][6] = Weight_20;

  assign X[0] = X_0;
  assign X[1] = X_1;
  assign X[2] = X_2;
  assign X[3] = X_3;
  assign X[4] = X_4;
  assign X[5] = X_5;
  assign X[6] = X_6;

  always @* begin
    c = 25'sb0000000000000000000000000;
    y = 16'sb0000000000000000;
    prodAB = 22'sb0000000000000000000000;
    slice_temp = 16'sb0000000000000000;
    // ytan = NN_Layer_Tanh_HDL(Bias,Weight,X)
    // This function implements NN Layer using Tanh Function
    // It is HDL supported, it can be used in HDL Code Generation
    // where
    //     Weight = Weights should be arranged as Row Vector
    //     X = Instances of Input Features should be arranged as Row Vector
    //     Bias = it can be Row or Column Vector
    //     Y = It is output vector (arranged as Column Vector)
    //         from all neurons of given layer.
    // Note: All inputs of this function should be in fixed point form
    // Word Length
    // Fractional Length

    for(k = 32'sd0; k <= 32'sd2; k = k + 32'sd1) begin
      c = 25'sb0000000000000000000000000;

      for(k_0 = 32'sd0; k_0 <= 32'sd6; k_0 = k_0 + 32'sd1) begin
        prodAB = Weight[k][k_0] * X[k_0];
        add_cast_2[k_0] = {c[24], c};
        add_cast_3[k_0] = {{4{prodAB[21]}}, prodAB};
        add_temp_0[k_0] = add_cast_2[k_0] + add_cast_3[k_0];
        if ((add_temp_0[k_0][25] == 1'b0) && (add_temp_0[k_0][24] != 1'b0)) begin
          c = 25'sb0111111111111111111111111;
        end
        else if ((add_temp_0[k_0][25] == 1'b1) && (add_temp_0[k_0][24] != 1'b1)) begin
          c = 25'sb1000000000000000000000000;
        end
        else begin
          c = add_temp_0[k_0][24:0];
        end
      end

      if (((c[24] == 1'b0) && (c[23] != 1'b0)) || ((c[24] == 1'b0) && (c[23:8] == 16'sb0111111111111111))) begin
        add_cast[k] = 16'sb0111111111111111;
      end
      else if ((c[24] == 1'b1) && (c[23] != 1'b1)) begin
        add_cast[k] = 16'sb1000000000000000;
      end
      else begin
        add_cast[k] = c[23:8] + $signed({1'b0, c[7]});
      end
      add_cast_0[k] = {add_cast[k][15], add_cast[k]};
      add_cast_1[k] = {{5{Bias[k][4]}}, {Bias[k], 7'b0000000}};
      add_temp[k] = add_cast_0[k] + add_cast_1[k];
      if ((add_temp[k][16] == 1'b0) && (add_temp[k][15] != 1'b0)) begin
        slice_temp = 16'sb0111111111111111;
      end
      else if ((add_temp[k][16] == 1'b1) && (add_temp[k][15] != 1'b1)) begin
        slice_temp = 16'sb1000000000000000;
      end
      else begin
        slice_temp = add_temp[k][15:0];
      end
      // Word Length
      // Fractional Length
      // Slopes and Offsets
      if (slice_temp < 16'sb1111100000000000) begin
        y = 16'sb1111110000000000;
      end
      else if (slice_temp < 16'sb1111101110011010) begin
        mul_temp[k] = 16'sb0000000010111000 * slice_temp;
        add_cast_4[k] = {mul_temp[k][31], mul_temp[k]};
        add_temp_1[k] = add_cast_4[k] + 33'sh1FFF47C00;
        y = add_temp_1[k][25:10];
      end
      else if ((slice_temp >= 16'sb1111101110011010) && (slice_temp <= 16'sb0000010001100110)) begin
        mul_temp_0[k] = 16'sb0000001101001000 * slice_temp;
        y = mul_temp_0[k][25:10];
      end
      else if (slice_temp <= 16'sb0000100000000000) begin
        mul_temp_1[k] = 16'sb0000000010111000 * slice_temp;
        add_cast_5[k] = {mul_temp_1[k][31], mul_temp_1[k]};
        add_temp_2[k] = add_cast_5[k] + 33'sh0000B8400;
        y = add_temp_2[k][25:10];
      end
      else begin
        y = 16'sb0000010000000000;
      end
      // Saturating between -1 to +1
      if (y < 16'sb1111110000000000) begin
        y = 16'sb1111110000000000;
      end
      else if (y >= 16'sb0000010000000000) begin
        y = 16'sb0000010000000000;
      end
      if ((y[15] == 1'b0) && (y[14:11] != 4'b0000)) begin
        ytan[k] = 16'sb0111111111111111;
      end
      else if ((y[15] == 1'b1) && (y[14:11] != 4'b1111)) begin
        ytan[k] = 16'sb1000000000000000;
      end
      else begin
        ytan[k] = {y[11:0], 4'b0000};
      end
    end

  end



  assign ytan_0 = ytan[0];

  assign ytan_1 = ytan[1];

  assign ytan_2 = ytan[2];

endmodule  // HiddenLayer1

